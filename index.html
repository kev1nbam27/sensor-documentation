<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<html class="en" lang="de"><!--<![endif]--><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">

    <title>Sensor Dokumentation</title>

    <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" type="text/css" href="index_files/font-awesome.css">
    <link rel="stylesheet" type="text/css" href="index_files/stroke.css">
    <link rel="stylesheet" type="text/css" href="index_files/bootstrap.css">
    <link rel="stylesheet" type="text/css" href="index_files/animate.css">
    <link rel="stylesheet" type="text/css" href="index_files/prettyPhoto.css">
    <link rel="stylesheet" type="text/css" href="index_files/style.css">

    <link rel="stylesheet" type="text/css" href="index_files/shCore.css" media="all">
    <link rel="stylesheet" type="text/css" href="index_files/shThemeRDark.css" media="all">

    <!-- CUSTOM -->
    <link rel="stylesheet" type="text/css" href="index_files/custom.css">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

<style id="fit-vids-style">.fluid-width-video-wrapper{width:100%;position:relative;padding:0;}.fluid-width-video-wrapper iframe,.fluid-width-video-wrapper object,.fluid-width-video-wrapper embed {position:absolute;top:0;left:0;width:100%;height:100%;}</style></head>

<body>
    <button onclick="topFunction()" id="myBtn" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>

    <script>
        var mybutton = document.getElementById("myBtn");
        window.onscroll = function() {scrollFunction()};
        function scrollFunction() {
            if (document.body.scrollTop > 1000 || document.documentElement.scrollTop > 1000) {
                mybutton.style.display = "block";
            } else {
                mybutton.style.display = "none";
            }
        }
        function topFunction() {
            window.scrollTo({ top: 0, behavior: 'smooth' })
            document.documentElement.scrollTo({ top: 0, behavior: 'smooth' })
        }

        document.addEventListener("DOMContentLoaded", () => {
            document.querySelector('#mode').addEventListener('click',()=>{
                document.querySelector('html').classList.toggle('dark');
            })
        });

        document.addEventListener("DOMContentLoaded", () => {
            document.querySelector('#lang').addEventListener('click',()=>{
                document.querySelector('html').classList.toggle('en');
                lang = document.querySelector('html').classList.contains('en') ? 'de' : 'en';
                $('div[lang='  + lang + ']').show();
                if (lang == "en") {
                    $('div[lang=' + "de" + ']').hide();
                } else if (lang == "de") {
                    $('div[lang=' + "en" + ']').hide();
                }
                })
        });


    </script>

    <div id="wrapper">

        <div id="mode">
            <div class="dark">
                <svg aria-hidden="true" viewBox="0 0 512 512">
                    <title>lightmode</title>
                    <path fill="currentColor" d="M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"></path>
                </svg>
            </div>
            <div class="light">
                <svg aria-hidden="true" viewBox="0 0 512 512">
                    <title>darkmode</title>
                    <path fill="currentColor" d="M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"></path>
                </svg>
            </div>
        </div>
        <div id="lang">
            <div class="de">
                <title>Deutsch</title>
                <p fill="currentColor">EN</p>
            </div>
            <div class="en">
                <title>English</title>
                <p fill="currentColor">DE</p>
            </div>
        </div>
        <div class="container">

            <section id="top" class="section docs-heading">

                <div class="row">
                    <div class="col-md-12">
                        <div class="big-title text-center" style="display: block;" lang="de">
                            <h1>CO2- und Feinstaub­messung</h1>
                            <p class="lead">Eine Arbeit von F. A. Andrist und L. J. Fondado</p>
                        </div>
                        <!-- end title -->

                        <div class="big-title text-center" style="display: none;" lang="en">
                            <h1>CO2 and Particulate Matter Measurement</h1>
                            <p class="lead">A work by F. A. Andrist and L. J. Fondado</p>
                        </div>
                        <!-- end title -->
                    </div>
                    <!-- end 12 -->
                </div>
                <!-- end row -->

                <hr>

            </section>
            <!-- end section -->

            <div class="row">
<div class="col-md-3" style="display: block;" lang="de">
                <nav class="docs-sidebar affix" data-spy="affix" data-offset-top="300" data-offset-bottom="200" role="navigation">
                    <ul class="nav"><li class="active"><a href="#line1">1. Vorwort</a></li><li class=""><a href="#line2">2. Dokumentation</a><ul class="nav"><li class=""><a href="#line2_1">2.1 Die einzelnen Bauteile</a></li><li class=""><a href="#line2_2">2.2 Der Zusammenbau und das Gehäuse</a></li><li class=""><a href="#line2_3">2.3 Programmierung</a></li></ul></li><li class=""><a href="#line3">3. Funktion der Sensoren</a><ul class="nav"><li class=""><a href="#line3_1">3.1 Die NDIR-Technologie</a></li><li class=""><a href="#line3_2">3.2 Die DLS-Technologie</a></li></ul></li><li class=""><a href="#line4">4. Der Messvorgang und die Datenauswertung</a><ul class="nav"><li class=""><a href="#line4_1">4.1 Grundlagen der Datenerfassung und Kalibrierung</a></li><li class=""><a href="#line4_2">4.2 Aufbereitung der Daten</a></li><li class=""><a href="#line4_3"> </a></li><li class=""><a href="#line4_4">4.3 Erstellung einer Website zur Betrachtung der Daten</a></li></ul></li><li class=""><a href="#line5">5. Die Funktionsweise einer Webseite</a><ul class="nav"><li class=""><a href="#line5_1">5.1 Begrifflichkeiten</a></li><li class=""><a href="#line5_2">5.2 Aufruf einer Website</a></li><li class=""><a href="#line5_3">5.3 HTML, CSS und JavaScript</a></li></ul></li><li class=""><a href="#line6">6. Datenanalyse</a><ul class="nav"><li class=""><a href="#line6_1">6.1 Innenraummessung</a></li><li class=""><a href="#line6_2">6.2 Aussenmessung</a></li></ul></li><li class=""><a href="#line7">7. Schlusswort</a></li><li class=""><a href="#line8">Glossar</a></li><li class=""><a href="#line9">Anhang</a></li><li class=""><a href="#line10">Quellen- und Bilderverzeichnis</a></li></ul></ul></nav></div><div class="col-md-9"><section id="line1" class="section">
                                <div class="row">
                                    <div class="col-md-12 left-align" style="display: block;" lang="de">
                                        <h2 class="dark-text">1. Vorwort<hr></h2>
                                    </div>
                                    <!-- end col -->
                                </div>
                                <!-- end row -->
                                <div class="row">
                                    <div class="col-md-12" style="display: block;" lang="de"><p class="justified-text">Diese Abschlussarbeit befasst sich mit Luft, genauer, mit dem Erfassen von Daten aus der Luft. Im Zuge der Covid-19-Pandemie, ausgelöst durch das Virus Sars-CoV-2, waren Begriffe, wie CO2-Erfassung oder Luftqualität in aller Munde, weshalb auch wir auf diese Thematik stiessen. Des Weiteren interessierte uns auch das Sammeln und Auswerten von Daten. So beschlossen wir uns näher mit diesen Themenfeldern zu befassen, indem wir ein Messgerät bauten, das die CO2- und die Feinstaubkonzentration in der Luft messen sollte. Unser Ziel war es nicht nur, ein solches Gerät zu konstruieren, sondern auch mit Hilfe des Gerätes Daten zu sammeln, auszuwerten und zu interpretieren. Ebenfalls wollten wir ein Verständnis darüber aufbauen, wie ein Sensor (hier ein NDIR und ein DLS) funktioniert, hierzu wollten wir neben der Dokumentation des Baus auch verschiedene Texte verfassen, die Verständnisfragen beantworten sollten. Das Gerät sollte, neben der Erfassung der Daten, auch den Benutzern momentane Werte liefern und diese auf sie aufmerksam machen, falls sie zu hoch sein sollten.<div><img class="img-responsive" src="images/rId8.png"></div></p><p class="justified-text">Wir beschlossen die Arbeit unter uns aufzuteilen, der eine sollte den Bau des Sensors und die anschliessende Programmierung übernehmen, während der andere die Recherche und das Schreiben übernimmt. Der Bau des Gerätes begann mit dem Zusammenbau der einzelnen Elektronikbauteile, aber auch ein individualisiertes Gehäuse war vonnöten, um den Sensor vor Umwelteinflüssen zu schützen.<div></div></p><p class="justified-text">Beim Rechercheteil unserer Arbeit legten wir einen besonderen Wert darauf, unsere Recherche möglichst nahe an wissenschaftlichen Publikationen zu betreiben und nicht verkürzte Zusammenfassungen aus Nachrichtendistributionsmedien zu zitieren. Hierzu nutzten wir die Suchmaschine «Google Scholar», diese verfügt über einen Index von Metadaten und Volltexten wissenschaftlicher Publikationen. <div></div></p></div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                    </section>
                    <!-- end section --><section id="line2" class="section">
                                <div class="row">
                                    <div class="col-md-12 left-align" style="display: block;" lang="de">
                                        <h2 class="dark-text">2. Dokumentation<hr></h2>
                                    </div>
                                    <!-- end col -->
                                </div>
                                <!-- end row -->
                                <div class="row">
                                    <div class="col-md-12" style="display: block;" lang="de"><h4 id="line2_1">2.1 Die einzelnen Bauteile</h4><p class="justified-text">Zu Beginn unseres Projektes mussten wir die Bauteile eruieren, einerseits die Sensoren, andererseits aber auch einen <strong>Mi</strong><strong>c</strong><strong>rocontroller</strong> und verschiedene Anschlüsse. Wir entschieden auf Basis des <strong>QWIIC/STEMMA QT</strong> Ökosystems zu arbeiten, da dieses Ökosystem es uns ermöglicht, die einzelnen Bauteile ohne viel Löten und anderweitige Sorgen, wie falsches Verbinden von einzelnen Jumperkabeln, zu verbinden. Nachdem wir uns für dieses Ökosystem entschlossen hatten, war es um einiges einfacher, entsprechende Sensoren zu eruieren, denn dieser spezielle Verbindungstyp liess nur gewisse Sensoren zu, die über die entsprechenden Schnittstellen verfügten. Als Sensor für die CO2-Konzentration wählten wir einen auf der NDIR-Technologie basierenden Sensor, den «SCD-30» des Herstellers Sensirion, dieser verfügt über eine Genauigkeit von ±30 ppm (parts per million = dt. „Teilchen pro Million“), und eine Operationsspannweite von 400-10`000 ppm, überdies verfügt der SCD-30 Sensor auch über ein Temperatur- und Luftfeuchtigkeitssensoren, mit deren Hilfe man die Daten besser interpretieren und Zusammenhänge erkennen kann[1]. Als Feinstaubsensoren, wählten wir den «PMSA003I» des Herstellers Adafruit, er misst die Partikel in der Luft die unter 10 µm, unter 2,5 µm und unter 1 µm gross sind; des Weiteren misst er die Teilchenkonzentration in 0,1l Luft in 0.3 µm, 0.5 µm, 1.0 µm, 2.5 µm, 5 µm und 10 µm[2].<div></div></p><p class="justified-text">Wir benötigten, neben Sensoren, auch einen Microcontroller, ein Zeitmessgerät, und einen Bildschirm. Der «nRF52840 Express» des Herstellers Adafruit, wurde unser Microcontroller, er hatte den Vorteil, einer nativen USB-Unterstützung, das heisst er kann ohne externen USB-Chip, von einem PC als USB-Gerät erkannt werden. Des Weiteren ist er mit Bluetooth Low Energy kompatibel, was uns ermöglicht kabellos über so gut wie jede Plattform mit dem Chip zu kommunizieren.<div><img class="img-responsive" src="images/rId11.jpeg"></div></p><p class="justified-text">Die Leistung des Chips war unseren Ansprüchen entsprechend mit einem ARM Cortex M4 Chip und einer Speicherkapazität von 1 MB Flash-Speicher[3] (Unsere Messdaten werden auf einer separaten MicroSD-Karte gespeichert, und nutzen den kleinen Speicher des Chips nicht). Das Display sollte es ermöglichen die momentanen Messwerte zu betrachten, aber auch gewisse Einstellungen des Gerätes, wie den Messintervall, oder das Bluetooth-Modul, zu verwalten. Der SerLCD 20x4 des Herstellers Sparkfun, erachteten wir als gute Lösung, er verfügt über ein 20x4 Pixel LCD und hat des Weiteren auch eine RGB-Hintergrundbeleuchtung, mit dieser konnten wir die optische Rückmeldung, bei zu hohen Werten sicherstellen.  Zuletzt noch fehlte ein Zeitmessgerät und ein MicroSD-Anschluss, da verhalf uns der «Adalogger FeatherWing» des Herstellers Adafruit, das Modul verfügte nicht nur über eine Echtzeituhr, sondern auch über einen MicroSD-Anschluss. Neben den Hauptmodulen benötigten wir auch ein Kabelkit und einen <strong>Shield</strong> für die Anschlüsse des STEMMA QT/QWIIC Ökosystems.<div></div></p><h4 id="line2_2">2.2 Der Zusammenbau und das Gehäuse</h4><p class="justified-text">Der Zusammenbau gestaltete sich nicht sehr schwer, da sich das meiste Löten erübrigte, einzig das Shield des Kabelsystems musste an den Microcontroller und den Adalogger angelötet werden. Aber die Vollständigkeit des Gerätes war hiermit noch nicht erreicht, das Gerät benötigte noch ein Gehäuse. Das Gehäuse konzipierten wir selbst, nahmen die Massen unserer Bauteile ab und modellierten in einer 3D-Software ein optimales Gehäuse. Wir versuchten es so klein als möglich zu konstruieren, aber gleichzeitig auch einen optimalen Luftdurchfluss gewährleisten zu können. Als das Gehäuse fertig modelliert war, druckten wir es mit Hilfe eines 3D-Druckers aus und bauten die einzelnen Komponenten ein. <div><img class="img-responsive" src="images/rId12.jpeg"></div></p><h4 id="line2_3">2.3 Programmierung</h4><p class="justified-text">Die letzte Hürde vor der Fertigstellung des Messgerätes stellte die Programmierung dar. Der Microcontroller gab zwei Möglichkeiten vor das Gerät zu programmieren, einerseits über «Circuitpython», eine simple Programmiersprache, die auf Python basiert, andererseits über die Arduino <strong>IDE</strong> (Integrated Development Environment), die die Programmiersprache C++ nutzt. Circuitpython verfügt über den Vorteil, dass man den Code direkt in das Gerät einspeisen kann, weil der Microcomputer über einen Python-Interpreter verfügt, und muss ihn nicht noch zuerst mit einem Compiler in «Maschinensprache» übersetzen. Die Arduino IDE/C++ Programmierung hat den grossen Vorteil viel weniger Zeit zu nutzen, da der Microcontroller nur noch die Befehle ausführen muss, ohne sie zu interpretieren, so spart man einiges an elektrischer Energie und Speicherplatz. Aus diesen Gründen entschieden wir uns für die Programmierung mit der Sprache C++, auch wenn sie anspruchsvoller war.<div></div></p><p class="justified-text">Zu Beginn implementierten wir die grundsätzlichen Funktionen, wie das Auslesen der Messdaten, das Speichern der Daten auf einer MicroSD-Karte und das Hinzufügen der Zeitmarker zu den entsprechenden Messdaten. Dies gestaltete sich insofern einfach, als die Hersteller der verschiedenen Teilsensoren eigene <strong>Bibliotheken</strong> und Leitfäden bereitstellten, die die Programmierung erleichterten, sodass wir nur Funktionen, die Werte der Sensoren angaben, abrufen mussten und diese dann mit den Zeitstempeln in eine CSV-Datei einfügen mussten. Dieser Zyklus wiederholte sich immer nach einer bestimmten Zeit, dem Messintervall.<div></div></p><p class="justified-text">Die Zeilen unseres Codes wuchsen rasant, bald stiessen wir auf eine der grossen Schwächen der Arduino IDE. Die Übersichtlichkeit von längeren Abschnitten an Code war äusserst gering, weshalb wir uns entschieden den Code fortan nicht mehr in der Arduino IDE, sondern in Visual Studio Code, eine andere IDE, den Code zu schreiben. <div><img class="img-responsive" src="images/rId13.jpeg"></div></p><p class="justified-text">Nachdem diese Hürde aus dem Weg geschafft war, konnten wir uns der weiteren Programmierung widmen. Zuerst entwickelten wir die Steuerung des Gerätes, diese sollte einerseits analog, aber auch digital kontrollierbar sein. Die analoge Steuerung gewährleisteten wir über einen Drehknopf.<div></div></p><p class="justified-text">Ein Drehknopf verfügt über zwei Steuerungsmöglichkeiten, nämlich das Drehen und das Drücken des Knopfes. Mithilfe des Drehens sollte das Wechseln des Menüs/der Auswahlmöglichkeiten kontrolliert werden, das Drücken sollte den ausgewählten Reiter öffnen, respektive aktivieren/deaktivieren. Die Programmierung fiel uns leicht, man musste nur jeder Bewegung des Drehknopfes die entsprechende Aktion anfügen, einzig die Erhaltung der vorgenommenen Einstellungen über mehrere Sessionen, konnten wir nicht programmieren, was aber auch kein grosses Problem darstellte, denn die Einstellungsmöglichkeiten sind nicht sehr umfangreich, man kann nur das RGB-Licht des Displays, den Messungsintervall und die Bluetoothfunktion verändern.<div></div></p><p class="justified-text">Die digitale Steuerung planten wir über eine Applikation namens «Bluefruit», die der Hersteller unseres Microcontrollers, Adafruit, bereitstellte. Diese Applikation, kann sich über Bluetooth mit verschiedensten Geräten, die dieser Verbindung fähig sind, verbinden. «Bluefruit» ermöglicht es nicht nur über die Bluetooth Verbindung zu kommunizieren, sondern es ist auch möglich andere Informationen, wie den Akkustand, und in unserem Fall, direkt die Daten graphisch über einen Plotter zu betrachten. Daneben erstellten wir noch eine Webapplikation, über die man ebenfalls Befehle an das Messgerät senden kann.<div></div></p><p class="justified-text">Zuletzt wollten wir noch ermöglichen, Dateien auf andere Geräte übertragen zu können. In der Rohform konnten keine Dateien übertragen werden, da das Gerät nicht als Speichermedium erkannt wurde, und man daher auch keinen Zugriff auf die Dateien hatte. Wir wollten aber auch nicht, dass man aus Versehen den Code auf dem Microcontroller löscht, daher sollte es nur möglich sein auf die Daten der MicroSD-Karte Zugriff zu haben. Hierfür mussten wir mit dem Messgerät ein USB-Speichermedium emulieren, das aber nur die Dateien auf der MicroSD-Karte ausgab. Den Grundcode lieferte ein Leitfaden, den wir dann mit einigen Anpassungen an unser Programm anfügten.<div></div></p></div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                    </section>
                    <!-- end section --><section id="line3" class="section">
                                <div class="row">
                                    <div class="col-md-12 left-align" style="display: block;" lang="de">
                                        <h2 class="dark-text">3. Funktion der Sensoren<hr></h2>
                                    </div>
                                    <!-- end col -->
                                </div>
                                <!-- end row -->
                                <div class="row">
                                    <div class="col-md-12" style="display: block;" lang="de"><h4 id="line3_1">3.1 Die NDIR-Technologie</h4><p class="justified-text">Der CO2 Sensor unseres Messgerätes basiert auf der NDIR-Technologie. NDIR ist ein Akronym, ausgeschrieben lautet es nichtdispersiver Infrarotsensor. NDIR Sensoren basieren auf der IR-Spektroskopie (Infrarotspektroskopie), diese findet viele Anwendungen in der Analyse von Stoffen aller Aggregatszustände. Die Grundfunktion der IR-Spektroskopie ist das Beschiessen eines Stoffes mit <strong>elektromagnetischer</strong><strong> Strahlung </strong>eines bestimmten Spektrums, des Infrarotspektrums (Wellenlänge 800nm bis 1mm). Die NDIR-Spektroskopie ist eine auf die Gasanalyse spezialisierte Art der IR-Spektroskopie. NDIR-Spektroskopien kommen in zwei verschiedenen Versionen zum Einsatz, die sich im Aufbau leicht unterscheiden. Einerseits wird die NDIR-Spektroskopie zur reinen Analyse eines Gases genutzt, das heisst eine Probe wird analysiert, und es wird bestimmt um welches Gas es sich handelt. Die andere Version, die auch unser Sensor verwendet, kommt in der Bestimmung der Gaskonzentration zum Einsatz.[5]<div><img class="img-responsive" src="images/rId14.png"></div></p><p class="justified-text">Die grundlegende Technik ist bei beiden Methoden dieselbe, man verfügt über eine Quelle die Infrarotstrahlung aussendet, vor der Quelle befindet sich eine Kammer, in der sich der zu analysierende Stoff befindet. Die Infrarotstrahlung trifft auf die Moleküle in der Kammer, die Moleküle absorbieren Teile der Infrarotstrahlung, denn sie werden in Schwingungen versetzt, das heisst die einzelnen Atome bewegen sich und das Molekül kann rotieren, diese Bewegungen benötigen Energie, die von der IR-Strahlung geliefert wird.[6] Es wird nicht die gesamte Strahlung absorbiert, sondern nur die Strahlung einer bestimmten Wellenlänge. Die übrige Strahlung passiert die Moleküle und trifft auf einen Detektor, dieser detektiert die aufgenommene Strahlung und daraus kann man ein Infrarotspektrum erstellen, auf dem erkennbar ist, welche Wellenlänge der Strahlung fehlt, daraus wird gefolgert um welchen Stoff es sich handelt, da jeder Stoff nur eine bestimmte Wellenlänge absorbiert. <div></div></p><p class="justified-text">Die zwei unterschiedlichen Implementierungen der NDIR-Technologie charakterisieren sich nur in der ausgesendeten Strahlung, wenn man die Konzentration messen will,<div></div></p><p class="justified-text"> sendet man nur Strahlung einer bestimmten Wellenlänge aus. Bei der Analyse eines Gases wird das gesamte IR-Spektrum genutzt.<div></div></p><h4 id="line3_2">3.2 Die DLS-Technologie</h4><p class="justified-text">Unter Feinstaub versteht man alle nicht gasförmigen Partikel in der Luft, also eine Mischung aus festen Partikeln und flüssigen Tropfen. Bei Messmethoden derselbigen, wird nur die Grösse und die Konzentration festgestellt, die stoffliche Zusammensetzung wird nicht analysiert. Die Einheit, in welcher diese angegeben werden, ist einerseits der sogenannte «PM-Standard», aber auch in absoluten Werten im Format Menge/0,1l Luft. Der PM-Standard ist eine relative Menge und gibt die Konzentration nicht in absoluten Werten an, es gibt grundsätzlich 2 PM-Standards, PM10 (alle Partikel >10 μm/m3 Luft) und PM 2,5 (alle Partikel <2,5 μm/m3 Luft), daneben gibt es noch PM 1, das aber nicht häufig gebraucht wird, da diese Partikel sehr selten sind.[7] Die absoluten Werte werden meist in 0,3 µm, 0,5 µm; 1,0 µm; 2,5 µm; 5 µm und 10 µm pro 0,1l Luft. <div></div></p><p class="justified-text">Die Messung erfolgt auf Basis des Konzepts der Streuung von Licht an Teilchen mit einem Durchmesser das kleiner als die Wellenlänge des Lichts ist. Der Aufbau eines solchen, als Dynamischer Lichtstreuungssensor (DLS-Sensor) bezeichneten, Messgerätes besteht aus einer monochromatischen (d.h. die Lichtquelle verfügt über eine spezifische Wellenlänge, und ist daher einfarbig) Lichtquelle (Laser), eine Kammer mit dem zu analysierenden Gemisch (Küvette) und einem Photometer, das Licht detektiert. Wenn man dann eine Probe beschiesst, und das gestreute Licht detektiert, wird man nicht einen uniformen Wert der Streuung feststellen, sondern einen Graphen, der sich relativ stark verändern kann. Da sich die Teilchen, die das Licht streuen in Bewegung sind (Brownsche Bewegung). Mit der Betrachtung der Veränderung über eine bestimmte Zeit kann man unter Mithilfe mathematischer Formeln, die das Durchmesser der Teilchen bestimmen. Den erhaltenen Wert kann man nutzen um mit weiteren Formeln die Anzahl an Teilchen ermitteln, indem man berechnet, welchen Anteil gewisse Teilchendurchmesser an am Gesamtvolumen bestimmt.[8]<div><img class="img-responsive" src="images/rId15.png"></div></p></div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                    </section>
                    <!-- end section --><section id="line4" class="section">
                                <div class="row">
                                    <div class="col-md-12 left-align" style="display: block;" lang="de">
                                        <h2 class="dark-text">4. Der Messvorgang und die Datenauswertung<hr></h2>
                                    </div>
                                    <!-- end col -->
                                </div>
                                <!-- end row -->
                                <div class="row">
                                    <div class="col-md-12" style="display: block;" lang="de"><h4 id="line4_1">4.1 Grundlagen der Datenerfassung und Kalibrierung</h4><p class="justified-text">Nachdem wir das Gerät und alle unterstützenden Mittel fertiggestellt hatten, kamen wir zum zweiten Hauptteil unseres Projektes, dem Erfassen und der Aufbereitung der Daten. Aber bevor die Datenerfassung beginnen konnte, musste der CO2-Sensor noch kalibriert werden, ansonsten wären die Messdaten sehr ungenau. Man könnte das Gerät zwar direkt in Aarau kalibrieren, jedoch verfügt Aarau über keinen genauen CO2-Sensor, einzig CO2 Werte einer Messstation der Universität Bern auf dem Jungfraujoch sind zugänglich. Daher mussten wir uns an einen Ort begeben, der einigermassen abgeschieden von Verbrennungsmotoren und Ähnlichem war, sodass der dortige CO2 Wert möglichst dem Wert des Jungfraujochs entspricht. Als jenen Ort wählten wir das Hombergegg auf 778 m.ü.M. aus. Dort kalibrierten wir den Sensor auf die Messwerte des Jungfraujochs. <div></div></p><p class="justified-text">Die Datenerfassung war trivial, einzig die Stromversorgung und die Platzierung des Gerätes erforderte einiges an Geschick. Die Stromversorgung wird bei unserem Gerät, wie vielleicht schon ersichtlich wurde, nicht über einen internen Akku gewährleistet, sondern über einen MicroUSB-Anschluss, der an eine Energiequelle angeschlossen wird. Als Energiequelle nutzten wir entweder Akkumulatoren (Powerbanks), oder wir schlossen das Gerät über einen Adapter direkt an den heimischen Stromanschluss an. Akkumulatoren kamen zum Einsatz, wenn wir an schwer erreichbaren oder abgelegenen Orten massen. Die Platzierung erforderte insofern Geschick, als das Gerät nicht an einer exponierten Stelle stehen sollte, da dadurch die Messergebnisse durch den Wind verfälscht werden könnten. Man muss das Gerät an eine möglichst windgeschützte Position stellen, aber gleichzeitig sollte die Luftzufuhr noch immer ausreichend sein.<div></div></p><p class="justified-text">Nach dem Abschluss der Positionierung und der Gewährleistung der Stromversorgung steht der Datenerfassung nichts im Wege, der Messvorgang muss nur noch über eine der vielen Kommunikationsmöglichkeiten gestartet werden. Während des Erfassens der Daten, benötigt das Gerät keinerlei Zugegensein, sodass auch über einen längeren Zeitraum, wir massen teilweise drei Tage am Stück, gemessen werden kann. <div></div></p><h4 id="line4_2">4.2 Aufbereitung der Daten</h4><h4 id="line4_3"> </h4><p class="justified-text">Auf die Datenerfassung folgt die Datenaufbereitung. Unsere Daten werden als CSV-Dateien aufgezeichnet, dies sind ganz normale Textdateien, die aber ein spezielles Format aufweisen. Das Format besteht aus Zeilenumbrüchen und Sonderzeichen. Die Zeilenumbrüche stehen für verschiedene Datensätze (die Werte der Sensoren zu einer bestimmten Zeit) und die Sonderzeichen trennen die verschiedenen Datenfelder (die Werte der einzelnen Sensoren) ab.[9] <div><img class="img-responsive" src="images/rId16.png"></div></p><p class="justified-text">Die CSV-Dateien importierten wir in eine zuvor erstellte Excel-Datei, die als Vorlage (engl. «Template») diente. In dieser Vorlage befand sich eine Seite mit einer Tabelle, in welche die Daten des CO2-Sensors, die Luftfeuchtigkeit, die Temperatur, und die verschiedenen Arten der erfassten Feinstaubwerten importiert wurden, und eine Seite mit Diagrammen, die die Werte der Tabelle darstellten. Um eine bessere Visualität der Feinstaubwerte zu erhalten, befand sich auf der dritten Seite eine Tabelle, in welcher die Mediane der Werte der ersten Tabelle berechnet werden. Da wir das Ganze als Vorlage konzipierten, konnten wir bei einem neuen zu betrachtendem Datensatz nur eine Kopie der Vorlage erstellen, und den neuen Datensatz in die erste Tabelle importieren, und schon haben wir viele Diagramme.<div><img class="img-responsive" src="images/rId17.png"></div></p><h4 id="line4_4">4.3 Erstellung einer Website zur Betrachtung der Daten</h4><p class="justified-text">Im Zuge unserer Betrachtungen stellten wir fest, dass ein Überblick über die aktuelle Messung und die Möglichkeit, die Diagramme vergrössern zu können, von Vorteil wären. Daher beschlossen wir, da wir noch Zeit zur Verfügung hatten und uns Webentwicklung schon länger interessierte, ein eigenes über das Internet abrufbares Werkzeug zu erstellen, das uns eben Genanntes ermöglichen sollte. Damit sollte es möglich sein, die Messwerte einer aktuellen Messung aus der Ferne betrachten zu können, solange das Messgerät mit einem an das Internet angeschlossenen Computer über Bluetooth verbunden ist. Neben dem Betrachten der Livedaten soll das Werkzeug es auch ermöglichen, die Daten vergangener Messungen zu betrachten, und diese auch zu exportieren. Wir strukturierten unser Werkzeug in zwei Websites auf, eine sollte als Datenbank fungieren, und die andere sollte die Website sein, auf die der Endbenutzer zugreift, um die Daten zu betrachten. Das Herzstück dieses Systems ist eine <strong>API</strong> (Application Programming Interface), die unserem Fall die Abfragen der Webseite (Client) an die Datenbank (Server) regelt, denn auf dem <strong>Server</strong> sind alle gesammelten Daten abgespeichert.<div></div></p><p class="justified-text">Wenn man die Daten einer bestimmten Messung sehen will, kann man auf den Button «Load Files» klicken, dann sendet der <strong>Client</strong> eine Abfrage nach den vorhandenen Dateien über ein <strong>HTTP-Protokoll</strong> an den Server, anschliessend werden die vorhandenen Dateien mit Datum und Zeitspanne angezeigt. Klickt man eine Datei an, wird wieder eine Abfrage an den Server, dieses Mal nach dem Inhalt der Datei, gesendet, dieser liefert die Daten an den Client, welcher die Daten aufschlüsselt und mit einer JavaScript-Bibliothek (CanvasJS) als Diagramme dargestellt. Diese Bibliothek ermöglicht auch das Exportieren der Diagramme in Form von JPEG- und PNG-Dateien. Neben einem JavaScript-Skript mussten wir auch ein HTML-Dokument und ein CSS-Stylesheet für unsere Webseite entwerfen. Die API wurde mit Python programmiert und über einen Dienst namens «Pythonanywhere» gehostet, der es möglich macht, Pythonanwendungen auf ihren Servern auszuführen. Die eigentliche Website (Client) für den Endbenutzer hosteten wir über GitHub. Des Weiteren hosteten wir über GitHub auch eine Website, auf der wir unsere schriftliche Arbeit publizierten.<div><img class="img-responsive" src="images/rId18.png"></div></p></div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                    </section>
                    <!-- end section --><section id="line5" class="section">
                                <div class="row">
                                    <div class="col-md-12 left-align" style="display: block;" lang="de">
                                        <h2 class="dark-text">5. Die Funktionsweise einer Webseite<hr></h2>
                                    </div>
                                    <!-- end col -->
                                </div>
                                <!-- end row -->
                                <div class="row">
                                    <div class="col-md-12" style="display: block;" lang="de"><h4 id="line5_1">5.1 Begrifflichkeiten</h4><p class="justified-text">Das Internet ist ein grosser Bestandteil unseres Lebens, es hat uns viele Vorteile gebracht, doch die wenigsten wissen, wie Websites überhaupt funktionieren. Mit diesem Abschnitt möchten wir ein wenig Aufklärung betreiben und die wichtigsten Grundlagen von Websites erläutern, auch wir erlernten in diesem Projekt zum ersten Mal die Grundlagen des Internets. Zuerst eine begriffliche Aufklärung, wie man vielleicht bereits bemerkt hat, nutze ich den Begriff «Website», im Deutschen ist aber auch das vermeindliche Synonym «Webseite» gebräuchlich, dies hat aber eine andere Bedeutung, während Webseite, nur eine bestimmte Seite des «WorldWideWeb» bezeichnet, umfasst der Begriff Website, die Gesamtheit aller Webseiten eines Anbieters, also die gesamte Präsenz im «WorldWideWeb».[10] Des Weiteren möchte ich auch auf die Begriffliche Differenz zwischen WorldWideWeb und Internet hinweisen. Was die meisten Menschen als Internet bezeichnen, sollte eigentlich als WorldWideWeb (nachfolgend als WWW bezeichnet) bezeichnet werden, denn Internet, bezeichnet nur global verbundene Netzwerke von Computern, während WWW einen Verbund aus Dokumenten und anderen Ressourcen, die mit einer URL abgerufen werden können bezeichnet.[11] <div><img class="img-responsive" src="images/rId19.png"></div></p><h4 id="line5_2">5.2 Aufruf einer Website</h4><p class="justified-text">Nun, da die Begrifflichkeiten geklärt sind, gehen wir die Funktion einer Website anhand unserer eigenen Webseiten durch. Zu Beginn steht immer das Aufrufen einer URL (Uniform Ressource Locator), bei unserer Webseite <a href="https://kev1nbam27.github.io/web-nus-plot/">https://kev1nbam27.github.io/web-nus-plot/</a>. Der genutzte Webbrowser sendet eine Anfrage an eine bestimmte Adresse, in der URL erkennbar als der Inhalt nach HTTP/HTTPS.<div><img class="img-responsive" src="images/rId20.png"></div></p><p class="justified-text">Der Inhalt ist aber nicht direkt als Adresse zu identifizieren, sondern wird zuerst von einer DNS-Adresse in eine IP-Adresse umgewandelt, aus "kev1nbam27.github.io/web-nus-plot" entsteht die IP-Adresse 185.199.111.153, die wiederum als Adresse im WWW ausfindig gemacht werden kann. Nachdem die Adresse gefunden wurde, schickt der Browser eine HTTP/HTTPS Anfrage nach einem HTML-Dokument an den adressierten Server, dieser schickt das angeforderte Dokument zurück.[12]<div></div></p><h4 id="line5_3">5.3 HTML, CSS und JavaScript</h4><p class="justified-text">Geschrieben ist das Dokument in HTML (HyperTextMarkupLanguage), HTML ist keine Programmiersprache, sondern eigentlich ein Textformat, das aber noch sogenannten HyperText enthält, das heisst, das Dokument enthält nicht nur den eigentlichen Text, sondern auch Elemente, die die Struktur des Textes bestimmen. Zum Beispiel identifizieren diese Titel, einfachen Text, Bilder oder auch Tabellen. Zur Identifikation werden sogenannte «Labels» zu Beginn und am Ende eines HTML-Elements eingefügt. Die Labels können auch mit Attributen genauer beschrieben werden. Ohne HTML wüsste ein Client nicht, welcher Text wie klassifiziert werden soll, so könnte es z.B. keine Unterschiede zwischen Titeln und normalem Text geben, oder auch Bilder wären unmöglich.[13]<div><img class="img-responsive" src="images/rId22.png"></div></p><p class="justified-text">Das erhaltene HTML-Dokument wird vom Browser anschliessend gerendert, das heisst, die Labels werden erkannt und der Text wird entsprechend formatiert.<div></div></p><p class="justified-text">HTML bestimmt grundsätzlich nicht, wie sich das Endresultat visuell gestaltet, sonst würde ein riesiger Mehraufwand bestehen, da der Autor zu jedem identifizierten Element hinzufügen müsste, wie dieses aussieht. Stattdessen werden sogenannte Stylesheets genutzt, für Webseiten meist CSS (Cascading Style Sheets). CSS bestimmt z.B. die Farben, die Schriftarten, aber auch das Layout der Webseite.<div></div></p><p class="justified-text">Elementen des HTML-Dokuments kann man dann ein bestimmtes visuelles Aussehen zuordnen, denn mit Hilfe der Labels können Elemente als Gruppen identifiziert werden, sodass jede Art von Element im gleichen Stil gerendert wird.[14] CSS ist in HTML integriert und der Client muss nicht noch Zusätzliches rendern. Nicht nur CSS als wichtiger Bestandteil in Websites integriert, auch eine Scriptsprache ist integriert, in 98% aller Webseiten ist dies JavaScript. JavaScript wird nicht auf dem Server ausgeführt, sondern auf dem Client, es ermöglicht viele fundamentale Funktionen, die Kommunikation mit dem Server, Diagramme, aber auch Animationen, werden erst durch JavaScript möglich.[15]<div></div></p></div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                    </section>
                    <!-- end section --><section id="line6" class="section">
                                <div class="row">
                                    <div class="col-md-12 left-align" style="display: block;" lang="de">
                                        <h2 class="dark-text">6. Datenanalyse<hr></h2>
                                    </div>
                                    <!-- end col -->
                                </div>
                                <!-- end row -->
                                <div class="row">
                                    <div class="col-md-12" style="display: block;" lang="de"><h4 id="line6_1">6.1 Innenraummessung</h4><p class="justified-text">Dies ist eine Ansicht einer der Zwei CO2 Messungen, die wir in Innenräumen durchgeführt haben. Die Feinstaubmessungen blieben konstant auf einem ungefähren Niveau und werden daher hier nicht angezeigt. Diese Messung fand über einen Zeitraum von ca. 2h statt in einem Klassenzimmer mit 22 anwesenden Personen.<div><img class="img-responsive" src="images/rId23.png"></div></p><p class="justified-text">Man kann zu Beginn und ab ca. 10:10 Uhr ein extremes Hoch des Wertes beobachten, dazwischen wiederum erkennt man ein stabiles Tief der Werte. Dies geschieht aufgrund der Fenster die während des Hochs geschlossen und während der längeren tiefen Periode konstant geöffnet waren. Das beweist, wie wichtig regelmässiges Lüften für eine gute Luftqualität ist, denn sonst steigt die CO2 Konzentration schnell ins Unermessliche. Leider sind Faktoren wie Personen, die das Zimmer verlassen nicht gut erkennbar, aber was erkennbar ist, ist die Anomalie inmitten des Tiefs, diese ist dadurch zu erklären, dass eine Person in das Gerät geblasen hat, wodurch der NDIR-Sensor stark ausgeschlagen hat, sich aber anschliessend schnell wieder eingependelt hat.<div></div></p><h4 id="line6_2">6.2 Aussenmessung</h4><p class="justified-text">Die Aussenmessungen konnten wir leider schlechter verwerten, da uns wichtige Eckdaten fehlten, wir konnten nur Feststellungen mit den uns zu Verfügung stehenden Daten treffen. So fiel uns eine Korrelation zwischen der relativen Luftfeuchtigkeit (Abb. 1) und der Feinstaubkonzentration (Abb.2) auf, und zwar verliefen diese proportional zueinander. Tatsächlich fanden wir darauf eine Studie, die unsere Beobachtung deckte[16]. Neben diesem Ereignis erkannte man nur eine generelle Abnahme der Feinstaubkonzentration in der Nacht, daher zu erklären, dass in der Nacht viel weniger Verkehr unterwegs ist. <div><img class="img-responsive" src="images/rId24.png"><img class="img-responsive" src="images/rId25.png"><img class="img-responsive" src="images/rId26.png"></div></p><p class="justified-text">Die CO2 Konzentration (Abb.3) verfügt über keinen erkennbaren Trend, was aber auch daran liegen kann, dass unser Messgerät nur auf 30 ppm genau ist. Schwankungen der CO2 Konzentration sind aber generell viel feiner und schlechter zu erkennen.<div></div></p></div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                    </section>
                    <!-- end section --><section id="line7" class="section">
                                <div class="row">
                                    <div class="col-md-12 left-align" style="display: block;" lang="de">
                                        <h2 class="dark-text">7. Schlusswort<hr></h2>
                                    </div>
                                    <!-- end col -->
                                </div>
                                <!-- end row -->
                                <div class="row">
                                    <div class="col-md-12" style="display: block;" lang="de"><p class="justified-text">Insgesamt sind wir sehr zufrieden, wir erreichten unser Ziel einen gut funktionierenden, portablen Luftqualitätssensor zu bauen. Auch die schriftliche Arbeit ist zufriedenstellend, auch wenn wir nicht alles erreichten, was wir wollten, der Rechercheteil ist kürzer ausgefallen als geplant und auch unser vorhergeplantes Design mit verschiedenen Informationskästchen neben dem Text machten wir nicht, da sonst die Leserlichkeit leiden würde und auch der Platz zu klein wäre. <div></div></p><p class="justified-text">Wir schufen aber auch zusätzliches, ungeplantes, wie die Website, auf der man die Daten betrachten kann. Aber natürlich lief nicht alles einwandfrei, der Bildschirm leidet  darunter, dass ein Verbindungskabel ab und an Wackelkontakte hat, und den Bildschirm dadurch unbrauchbar macht. Was wir auch noch zurückstufen mussten waren Langzeitmessungen, zum einen wurden diese Dateien sehr gross, eine Messung die ca. 35h umfasste brauchte sehr lange, um von der Website geplottet zu werden, manchmal hängte sich die Website auch auf, daneben stellte auch der Sensor an sich einen Stolperstein für lange Messungen dar, denn bei langer Laufzeit leidet das Gerät und kann sich auch einfach abschalten, so geschehen bei ebengenannter längster Messung von ca. 35h.<div></div></p><p class="justified-text"> Die Messergebnisse an sich liessen wenig zu Wünschen übrig, was aber auch nicht so gut gelang, war das Interpretieren von Daten, da uns schlichtweg meistens andere Daten wie Wetterdaten oder Verkehrsdaten fehlten, um eine Relation erkennen zu können. Wir konnten einzig Verbindungen zwischen Messwerten untereinander oder zwischen Messwerten und der Zeit herstellen. <div></div></p><p class="justified-text">Alles in allem gelang der Kernteil, einen Sensor zu bauen, gut, auch verschiedene Zusätze konnten realisiert werden, wie die ungeplante Website. Durch dieses Projekt erwarben wir viele neue Fertigkeiten und Wissen, es zeigte uns wie wichtig die Planung von Arbeiten ist, aber auch wie, und mit welchen Werkzeugen man eine wissenschaftliche Recherche durchführen kann, und wie das Erstellen von Websites funktioniert.<div></div></p></div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                    </section>
                    <!-- end section --><section id="line8" class="section">
                                <div class="row">
                                    <div class="col-md-12 left-align" style="display: block;" lang="de">
                                        <h2 class="dark-text">Glossar<hr></h2>
                                    </div>
                                    <!-- end col -->
                                </div>
                                <!-- end row -->
                                <div class="row">
                                    <div class="col-md-12" style="display: block;" lang="de"><p class="justified-text"><strong>API:</strong> Eine API ist eine Schnittstelle, die den Zugriff auf Funktionen anderer Systeme in Art und Weise definiert. Eine Unterkategorien der APIs sind die Web-APIs, oder auch als Webservice bezeichnet. Basierend auf dem Client/Server Prinzip, sendet der Client eine Anfrage an den Server, was spezifische Funktionen auslöst, worauf der Client eine Antwort erhält. Die API legt den Rahmen dieser Interaktion fest.<div></div></p><p class="justified-text"><strong>Bibliotheken:</strong> Sammlungen an Programmcode-Bestandteilen, die gewisse Funktionen erfüllen können, dadurch muss der Programmierende nicht jede Funktion von Grund auf implementieren.<div></div></p><p class="justified-text"><strong>Client/Server Prinzip: </strong>Das Client/Server Prinzip regelt, wie Internetdienste genutzt werden können, Die Server sind Anbieter (auch als Hosts bezeichnet) von Internetdiensten, wie dem WWW oder E-Mail, die ständig auf Anfragen warten. Der Client ist der, der eine Anfrage senden kann, aber keine Anfragen beantwortet, wenn man auf seinem PC eine Webadresse aufruft fungiert der verwendete Browser als Client<div></div></p><p class="justified-text"><strong>Elektromagnetische Strahlung:</strong> Eine Art von Wellen, die durch elektrische und magnetische Wellen gebildet werden, elektromagnetische Wellen, sind von grösster Bedeutung für den Menschen. Sie sind das Licht, und erfüllen viele andere Aufgaben, Radiowellen sind elektromagnetische Wellen, unsere Mikrowellen funktionieren über elektromagnetische Wellen und auch viele andere Anwendungen benötigen elektromagnetische Wellen.<div></div></p><p class="justified-text"><strong>Microcontroller:</strong> Ein Microcontroller kann man sich eigentlich wie einen PC vorstellen, er verfügt über einen Prozessor, Speicher und Schnittstellen. Was den Microcontroller von einem PC unterscheidet, ist, dass Microcontroller nicht dafür ausgelegt sind, viele verschiedene Aufgaben zu erfüllen, sondern meist nur eine bestimmte Menge an Aufgaben. Des Weiteren ist ein wichtiges Unterscheidungskriterium, dass Microcontroller Peripheriefunktionen enthalten, das heisst, sie sind an mehrere untergeordnete Geräte, wie Sensoren, angeschlossen, die sie kontrollieren.<div></div></p><p class="justified-text"><strong>HTTP/HTTPS-Protokoll: </strong> HTTP (für HyperText Transport Protocol) kann man als die Sprache definieren, in der Client und Server kommunizieren. Dies erfolgt in einem festen Ablauf, aus Anfragen und Antworten, weshalb es als Protokoll bezeichnet wird. HTTPS stellte eine abhörsichere Version von HTTP dar, dies geschieht, indem der Datenverkehr verschlüsselt wird.<div></div></p><p class="justified-text"><strong>IDE:</strong><strong> </strong>Eine Software, die alle Werkzeuge, die zum Programmieren benötigt werden, bereitstellt: Einen Editor, ein «Rechtschreibprogramm», das den Code auf Fehler überprüft (Debugger genannt), sowie einen Interpreter/Compiler, dieser übersetzt den geschriebenen für Menschen lesbare Code in Maschinencode.<div></div></p><p class="justified-text"><strong>Shield:</strong><strong> </strong>Ein Shield ist eine Platine, die an einen Microcontroller angeschlossen wird, sie ermöglicht es an den Komponenten an den Microcontroller anzuschliessen, deren Verbindungsmöglichkeit nicht durch einen bereits vorhandenen Steckplatz abgedeckt wird. In unserem Fall ermöglichte das Shield die Verbindung über QWIIC/STEMMA QT, aber es sind auch ganz andere Verbindungen möglich, wie Ethernet, USB oder MicroSD.<div></div></p></div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                    </section>
                    <!-- end section --><section id="line9" class="section">
                                <div class="row">
                                    <div class="col-md-12 left-align" style="display: block;" lang="de">
                                        <h2 class="dark-text">Anhang<hr></h2>
                                    </div>
                                    <!-- end col -->
                                </div>
                                <!-- end row -->
                                <div class="row">
                                    <div class="col-md-12" style="display: block;" lang="de"><p class="justified-text">Wir nutzen in unserem Projekt das QWIIC/STEMMA QT Ökosystem für die Verbindung der verschiedenen Module unseres Sensors. Es ermöglicht uns effizienter und einfacher das Gerät zu konstruieren, aber was ist dieses System überhaupt?<div></div></p><p class="justified-text">Um das zu klären, muss man weiter zurück gehen. Die Verbindungen der einzelnen Sensoren laufen zum Microcontroller, es wird nicht nur Elektrizität übertragen, sondern auch Daten. Diese Daten können auf drei verschiedene Varianten übertragen. Es gibt einerseits die UART (Universal Asynchronous Receiver Transmitter) Verbindungsart, bei dieser werden die Komponenten über 2 Kabel verbunden, diese sind aber nur für die Kommunikation an sich, d.h. die Datenübertragung, verantwortlich, ein Taktsignal (verantwortlich für eine synchrone, fehlerfreie Kommunikation) fehlt, und muss daher vom Empfänger berechnet werden, was dieses System ineffizient und fehleranfällig macht.[4]<div></div></p><p class="justified-text">Die zweite Verbindungsart, SPI (Serial Peripheral Interface), verfügt, neben den beiden für die Datenübertragung verantwortlichen Schnittstellen, auch über eine Schnittstelle für das Taktsignal, sodass alle Komponenten synchron sind. Neben diesen drei Anschlüssen verfügt SPI aber auch noch über eine zusätzliche Schnittstelle pro angeschlossener Komponente, was dazu führt, dass bei kleinen Geräten die Kabel sehr unübersichtlich sind und der Platz noch enger wird.[4]<div></div></p><p class="justified-text">Die dritte Verbindungsart I2C (Inter-Integratet Circuit), verfügt über nur zwei Schnittstellen, eine Datenschnittstelle (SDA), und eine Taktsignalschnittstelle (SCL). Bei mehreren peripheren Komponenten werden keine zusätzlichen Schnittstellen benötigt. Der Empfänger wird nicht über ein separates Signal angesprochen, sondern über das übertragene Datensignal selbst. Denn das Datensignal besteht nicht nur aus den zu übertragenden Daten,<div><img class="img-responsive" src="images/rId27.jpeg"></div></p><p class="justified-text">sondern ist in mehrere Blöcke aufgeteilt. Zuerst wird immer ein Addressblock übertragen, der bestimmt, welche Komponente der Empfänger ist, anschliessend werden beliebig viele Datenblöcke übertragen. <div></div></p><p class="justified-text">Das QWIIC/STEMMA QT Ökosystem nutzt die I2C-Übertragung, der grosse Vorteil liegt nicht nur bei der Übertragung, sondern auch bei der Hardware. Die verschiedenen Anschlüsse, die zwei I2C-Anschlüsse, sowie eine Erdung und ein 3,3 Volt Kabel, werden nämlich in einem Kabel vereint, das über Pins an die Leiterplatte angeschlossen wird.[4] <div></div></p></div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                    </section>
                    <!-- end section --><section id="line10" class="section">
                                <div class="row">
                                    <div class="col-md-12 left-align" style="display: block;" lang="de">
                                        <h2 class="dark-text">Quellen- und Bilderverzeichnis<hr></h2>
                                    </div>
                                    <!-- end col -->
                                </div>
                                <!-- end row -->
                                <div class="row">
                                    <div class="col-md-12" style="display: block;" lang="de"><p class="justified-text"><strong>Bilderverzeichnis</strong><strong>:</strong><div></div></p><p class="justified-text">Titelbild, Bilder 1-3, 6-16: Eigenproduktion<div></div></p><p class="justified-text">Bild 5 (S.10): Matt, 2009, elektromagnetisches Spektrum [Diagramm] <a href="https://upload.wikimedia.org/wikipedia/commons/thumb/2/20/EM-Spektrum.svg/2560px-EM-Spektrum.svg.png">https://upload.wikimedia.org/wikipedia/commons/thumb/2/20/EM-Spektrum.svg/2560px-EM-Spektrum.svg.png</a><div></div></p><p class="justified-text">Bild 6 (S.11): Jones M., 2017, dynamische Lichtstreuung[Diagramm] <a href="https://upload.wikimedia.org/wikipedia/commons/thumb/4/43/DLS.svg/2560px-DLS.svg.png">https://upload.wikimedia.org/wikipedia/commons/thumb/4/43/DLS.svg/2560px-DLS.svg.png</a><div></div></p><p class="justified-text">Bild 17 (S.24): SFUPTOWNMAKER, 2022, I2C Communication Protocol [Diagramm] <a href="https://cdn.sparkfun.com/assets/learn_tutorials/8/2/I2C_Basic_Address_and_Data_Frames.jpg">https://cdn.sparkfun.com/assets/learn_tutorials/8/2/I2C_Basic_Address_and_Data_Frames.jpg</a><div></div></p><p class="justified-text"><strong>Quellenverzeichnis</strong><strong>:</strong><div></div></p><p class="justified-text">[1]<a href="https://sensirion.com/de/produkte/katalog/SCD30/">https://sensirion.com/de/produkte/katalog/SCD30/</a><div></div></p><p class="justified-text">[2]<a href="https://learn.adafruit.com/pmsa003i">https://learn.adafruit.com/pmsa003i</a><div></div></p><p class="justified-text">[3]<a href="https://www.adafruit.com/product/4062">https://www.adafruit.com/product/4062</a><div></div></p><p class="justified-text">[4]<a href="https://learn.sparkfun.com/tutorials/i2c/all">https://learn.sparkfun.com/tutorials/i2c/all</a><div></div></p><p class="justified-text">[5]Jason Steitz & Chenan Tong(2013) NDIR CO2 Gas detection system <a href="https://www.ti.com/lit/an/snaa207/snaa207.pdf">https://www.ti.com/lit/an/snaa207/snaa207.pdf</a><div></div></p><p class="justified-text">[6]Stuart B. (2004): Infrared spectroscopy: Fundamentals and applications<div></div></p><p class="justified-text">[7]<a href="https://www.dep.pa.gov/Business/Air/BAQ/PollutantTopics/Pages/The-Particulate-Matter-Standard.aspx">https://www.dep.pa.gov/Business/Air/BAQ/PollutantTopics/Pages/The-Particulate-Matter-Standard.aspx</a><div></div></p><p class="justified-text">[8]Simone Simões Amaral et al., 2015: An Overview of Particulate Matter Measurement Instruments <div></div></p><p class="justified-text">[9]<a href="https://de.wikipedia.org/wiki/CSV_(Dateiformat)">https://de.wikipedia.org/wiki/CSV_(Dateiformat)</a><div></div></p><p class="justified-text">[10]<a href="https://www.duden.de/sprachwissen/sprachratgeber/website-oder-webseite">https://www.duden.de/sprachwissen/sprachratgeber/website-oder-webseite</a><div></div></p><p class="justified-text">[11]<a href="https://www.w3.org/Help/#webinternet">https://www.w3.org/Help/#webinternet</a><div></div></p><p class="justified-text">[12]<a href="https://wiki.selfhtml.org/wiki/URL#Zugriff_auf_Ressourcen_mittels_einer_URL">https://wiki.selfhtml.org/wiki/URL#Zugriff_auf_Ressourcen_mittels_einer_URL</a><div></div></p><p class="justified-text">[13]<a href="https://wiki.selfhtml.org/wiki/HTML/Tutorials/Einstieg/Erste_Schritte">https://wiki.selfhtml.org/wiki/HTML/Tutorials/Einstieg/Erste_Schritte</a><div></div></p><p class="justified-text">[14]<a href="https://wiki.selfhtml.org/wiki/CSS/Tutorials/Einstieg/Stylesheets_einbinden$">https://wiki.selfhtml.org/wiki/CSS/Tutorials/Einstieg/Stylesheets_einbinden$</a><div></div></p><p class="justified-text">[15]<a href="https://developer.mozilla.org/docs/Learn/Getting_started_with_the_web/JavaScript_basics">https://developer.mozilla.org/docs/Learn/Getting_started_with_the_web/JavaScript_basics</a><div></div></p><p class="justified-text">[16]Gernan Hernandez et al. (2017): Temperature and Humidity effects on Particulate Matter Concentrations in a Subtropical Climate during Winter. <a href="https://www.researchgate.net/publication/332707202_Temperature_and_humidity_effects_on_particulate_matter_concentrations_in_a_sub-tropical_climate_during_winter">https://www.researchgate.net/publication/332707202_Temperature_and_humidity_effects_on_particulate_matter_concentrations_in_a_sub-tropical_climate_during_winter</a><div></div></p>
                        </div>
                        <!-- end row -->

                    </section>
                    <!-- end section -->

                </div>
                <!-- // end .col -->

            </div>
            <!-- // end .row -->

        </div>
        <!-- // end container -->

    </div>
    <!-- end wrapper -->

    <script src="index_files/jquery_003.js"></script>
    <script src="index_files/bootstrap.js"></script>
    <script src="index_files/retina.js"></script>
    <script src="index_files/jquery.js"></script>
    <script src="index_files/wow.js"></script>
    <script src="index_files/jquery_002.js"></script>

    <!-- CUSTOM PLUGINS -->
    <script src="index_files/custom.js"></script>
    <script src="index_files/main.js"></script>

    <script src="index_files/shCore.js"></script>
    <script src="index_files/shBrushXml.js"></script>
    <script src="index_files/shBrushCss.js"></script>
    <script src="index_files/shBrushJScript.js"></script>




</body></html>