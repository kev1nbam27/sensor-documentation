<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<html lang="en">
<!--<![endif]-->

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">

    <title>Sensor Dokumentation</title>

    <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" type="text/css" href="fonts/font-awesome-4.3.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="css/stroke.css">
    <link rel="stylesheet" type="text/css" href="css/bootstrap.css">
    <link rel="stylesheet" type="text/css" href="css/animate.css">
    <link rel="stylesheet" type="text/css" href="css/prettyPhoto.css">
    <link rel="stylesheet" type="text/css" href="css/style.css">

    <link rel="stylesheet" type="text/css" href="js/syntax-highlighter/styles/shCore.css" media="all">
    <link rel="stylesheet" type="text/css" href="js/syntax-highlighter/styles/shThemeRDark.css" media="all">

    <!-- CUSTOM -->
    <link rel="stylesheet" type="text/css" href="css/custom.css">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body>
    <button onclick="topFunction()" id="myBtn" title="Go to top"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>

    <script>
        var mybutton = document.getElementById("myBtn");
        window.onscroll = function() {scrollFunction()};
        function scrollFunction() {
            if (document.body.scrollTop > 1000 || document.documentElement.scrollTop > 1000) {
                mybutton.style.display = "block";
            } else {
                mybutton.style.display = "none";
            }
        }
        function topFunction() {
            window.scrollTo({ top: 0, behavior: 'smooth' })
            document.documentElement.scrollTo({ top: 0, behavior: 'smooth' })
        }

        document.addEventListener("DOMContentLoaded", () => {
            document.querySelector('#mode').addEventListener('click',()=>{
                document.querySelector('html').classList.toggle('dark');
            })
        });


    </script>

    <div id="wrapper">

        <div id="mode" >
            <div class="dark">
                <svg aria-hidden="true" viewBox="0 0 512 512">
                    <title>lightmode</title>
                    <path fill="currentColor" d="M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"></path>
                </svg>
            </div>
            <div class="light">
                <svg aria-hidden="true" viewBox="0 0 512 512">
                    <title>darkmode</title>
                    <path fill="currentColor" d="M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"></path>
                </svg>
            </div>
        </div>

        <div class="container">

            <section id="top" class="section docs-heading">

                <div class="row">
                    <div class="col-md-12">
                        <div class="big-title text-center">
                            <h1>CO2- und Feinstaubmessung</h1>
                            <p class="lead">Eine Arbeit von F. A. Andrist und L. J. Fondado</p>
                        </div>
                        <!-- end title -->
                    </div>
                    <!-- end 12 -->
                </div>
                <!-- end row -->

                <hr>

            </section>
            <!-- end section -->

            <div class="row">

                <div class="col-md-3">
                    <nav class="docs-sidebar" data-spy="affix" data-offset-top="300" data-offset-bottom="200" role="navigation">
                        <ul class="nav">
                            <li><a href="#line1">Einleitung</a></li>
                            <li><a href="#line2">Dokumentation</a></li>
                            <li><a href="#line3">Sensoren</a></li>
                            <li><a href="#line4">Messung</a></li>
                            <li><a href="#line5">Auswertung der Daten</a></li>
                            <li><a href="#line6">Funktion einer Website</a></li>
                            <li><a href="#line7">Datenanalyse</a></li>
                            <li><a href="#line8">Schlusswort</a></li>
                        </ul>
                    </nav >
                </div>
                <div class="col-md-9">
                    <section id="line1" class="section">

                        <div class="row">
                            <div class="col-md-12 left-align">
                                <h2 class="dark-text"> Einleitung <hr></h2>
                            </div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                        <div class="row">
                            <div class="col-md-12">
                                <p>Diese Abschlussarbeit befasst sich mit Luft, genauer, mit dem Erfassen von Daten aus der Luft und den Auswirkungen von Unreinheiten in der Luftqualität. Im Zuge der Covid-19-Pandemie, ausgelöst durch das Virus Sars-CoV-2, waren Begriffe, wie CO2-Erfassung oder Luftqualität in aller Munde, deshalb stiessen auch wir auf diese Thematik. Zugleich interessierte uns auch das Sammeln und Auswerten von Daten in einem wissenschaftlichen Kontext, so beschlossen wir uns näher damit zu befassen, indem wir ein Messgerät bauen, das verschiedene Partikel, die CO2 und die Feinstaubkonzentration, in der Luft messen sollte. Unser Ziel war es jedoch nicht nur, ein solches Gerät zu konstruieren, sondern mit Hilfe des Gerätes auch Daten zu sammeln, und diese auszuwerten und zu Interpretieren. Ebenfalls wollten wir ein Verständnis darüber haben, wie ein Sensor (hier ein NDIR) funktioniert, und was diese Unreinheiten in der Luft für Auswirkungen auf den Menschen und die Umwelt haben. Hierzu haben wir neben der Dokumentation des Baus und den verschiedenen Testreihen mit dem Sensor auch verschiedene möglichst aktuelle Texte verfasst, die diese Verständnisfragen beantworten sollen. Das Gerät sollte nicht nur dem Erfassen, und der anschliessenden Aufbereitung von Daten dienen, sondern es sollte den Benutzern auch die momentanen Werte und, falls diese Werte zu hoch sein sollten, ein visuelles Signal aussenden, in Form von roten Lichts.</p>

                                <p>Wir beschlossen die Arbeit unter uns aufzuteilen, der eine sollte den Bau des Sensors und die anschliessende Programmierung übernehmen, der anderen sollte die Recherche und das Ausarbeiten der Testkonzepte übernehmen. Der Bau des Gerätes begann mit dem Zusammenbau der einzelnen Elektronikbauteile, weil wir unseren Sensoren auf Basis des modularen QWIIC/STEMMA QT Ökosystems zusammenbauen wollten, gestaltete der Bau sich relativ einfach, wir mussten nur wenige Bauteile löten, da diese durch ebengenanntes Ökosystem einfach zu verbinden waren. Des Weiteren war ein individualisiertes Gehäuse von Nöten, um den Sensor nicht andauernd Umwelteinflüssen auszusetzen und um den Lufteinfall zu regeln. Da wir über einen 3D-Drucker verfügten, nahmen wir diesen zu Hilfe für unser Gehäuse.</p>

                                <p>Beim Rechercheteil unserer Arbeit, legten wir einen besonderen Wert darauf, möglichst nahe an wissenschaftlichen Publikationen unsere Recherche zu betreiben und nicht profane verkürzte Zusammenfassungen aus Nachrichtendistributions-medien zu zitieren. Hierzu nutzten wir die Suchmaschine «Google Scholar», diese verfügt über einen Index von Metadaten und Volltexten wissenschaftlicher Publikationen. Wir legten unser Augenmerk zu Beginn vor allem auf Metaanalysen und systematische Übersichtsarbeiten (engl. «Reviews»), anschliessend, falls nötig, suchten wir noch spezifischere Publikationen.</p>
                            </div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                    </section>
                    <!-- end section -->

                    <section id="line2" class="section">

                        <div class="row">
                            <div class="col-md-12 left-align">
                                <h2 class="dark-text">Dokumentation<hr></h2>
                            </div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->
                        
                        <div class="row">
                            <div class="col-md-12">
                                <p>Zu Beginn unseres Projektes, mussten wir die einzelnen Bauteile evaluieren, einerseits die verschiedenen Sensoren, aber auch einen Mikrocontroller und verschiedene Anschlüsse. Wir entschieden uns auf Basis des QWIIC/STEMMA QT Ökosystems aufzubauen, da dieses Ökosystem es uns ermöglicht die einzelnen Bauteile, ohne viel Löten und anderweitige Sorgen, wie falsches Verbinden von einzelnen Jumperkabeln, zu verbinden. Nachdem wir uns für dieses Ökosystem entschlossen hatten, war es um einiges einfacher entsprechende Sensoren zu finden, denn dieser spezielle Verbindungstyp liess nur gewisse Sensoren zu, die über die entsprechenden Schnittstellen verfügten. Als Sensoren für die CO2-Konzentration wählten wir einen auf der NDIR-Technologie basierenden Sensoren, den SCD-30 des Herstellers Sensirion, dieser verfügt über eine Genauigkeit von ±30 ppm (parts per million = dt. „Teilchen pro Million“), und eine Operationsspannweite von 400-10`000 ppm, überdies verfügt der SCD-30 Sensor auch über ein Temperatur– und Luftfeuchtigkeitssensoren, mit deren Hilfe man die Daten besser interpretieren und Zusammenhänge erkennen kann[1]. Als Feinstaubsensoren, wählten wir den PMSA003I des Herstellers Adafruit, er misst die Partikel in der Luft die unter 10 µm, unter 2,5 µm und unter 1 µm gross sind; des Weiteren misst er die Teilchenkonzentration von 0,1l Luft in 0,3 µm, 0,5 µm; 1,0 µm; 2,5 µm; 5 µm und 10 µm[2].</p>

                                <p>Aber wir benötigten nicht nur Sensoren, sondern auch einen Mikrocontroller, ein Zeitmessgerät, und ein Display. Der «nRF52840 Express» des Herstellers Adafruit, wurde unser Microcontroller, er hatte den Vorteil, einer nativen USB-Unterstützung (er kann ohne externen USB-Chip, von einem PC als USB-Gerät erkannt werden, z.B. als Maus, Tastatur oder auch als Speichermedium), und er ist mit Bluetooth Low Energy kompatibel, was uns ermöglicht kabellos über so gut wie jede Plattform mit dem Chip zu kommunizieren. Die Leistung des Chips war ebenfalls angemessen mit einem ARM Cortex M4 Chip und einer Speicherkapazität von 1 MB Flash-Speicher[3] (hier ist anzumerken, dass unsere Messdaten auf einer separaten MicroSD-Karte gespeichert sind). Das Display sollte es ermöglichen die momentanen Messwerte zu betrachten, aber auch gewisse Einstellungen des Gerätes, wie den Messintervall, oder das Bluetooth-Modul, zu verwalten. Der SerLCD 20x4 des Herstellers Sparkfun, erachteten wir als gute Lösung, er verfügt über ein 20x4 Pixel LCD und hat des Weiteren auch eine RGB-Hintergrundbeleuchtung, mit dieser konnten wir die optische Rückmeldung, bei zu hohen Werten sicherstellen.  Zuletzt noch als wichtiges Modul fehlte ein Zeitmessgerät, da verhalf uns der «Adalogger FeatherWing» des Herstellers Adafruit, das Modul verfügte nicht nur über eine Echtzeituhr, sondern auch über einen MicroSD-Anschluss. Neben den Hauptmodulen benötigten wir auch ein Kabelkit und ein HUB für die Anschlüsse des STEMMA QT/QWIIC Ökosystems.</p>

                                <p>Der Zusammenbau des Gerätes gestaltete sich nicht sehr schwer, da sich das meiste Löten erübrigte, einzig musste das HUB des Kabelsystems an den Microcontroller und den Adalogger angelötet werden. Aber die Vollständigkeit des Gerätes, war hiermit noch nicht erreicht, das Gerät benötigte noch ein Gehäuse. Das Gehäuse konzipierten wir selbst, nahmen die Massen unserer Bauteile ab und modellierten in einer 3D-Software ein optimales Gehäuse. Wir versuchten es so klein als möglich zu konstruieren, aber gleichzeitig auch einen optimalen Luftdurchfluss gewährleisten zu können. Als das Gehäuse fertig modelliert war, druckten wir es mit Hilfe eines 3D-Druckers aus und bauten die einzelnen Komponenten ein.  Dieses Gehäuse, war aber nicht unser finales Gehäuse, denn nach mehreren Einsätzen fiel uns auf, dass es noch mehrere Schwächen aufwies.</p>

                                <p>Die letzte Hürde vor der Fertigstellung des Messgerätes, war die Programmierung. Der Microcontroller gab zwei Möglichkeiten vor das Gerät zu programmieren, einerseits über «Circuitpython», eine simple Programmiersprache die auf Python basiert, oder über die Arduino IDE (Integrated Development Environment) die die Programmiersprache C++ nutzt. Circuitpython verfügt über den Vorteil, dass man den Code direkt in das Gerät einspeisen kann, weil der Microcomputer über einen Python-Interpreter verfügt, mit dessen Hilfe kann man das Programm direkt in Textform dem Gerät übergeben, und muss es nicht noch zuerst mit einem Compiler in «Maschinensprache» übersetzen. Die Arduino IDE/C++ Programmierung hatte den grossen Vorteil viel weniger Zeit zu nutzen, da der Microcontroller nur noch die Befehle ausführen musste, ohne sie zu interpretieren, so sparte man auch einiges an elektrischem Energieverbrauch und Speicherplatz. Aus diesen Gründen entschieden wir uns für die Programmierung mit der Sprache C++, auch wenn sie anspruchsvoller war.</p>

                                <p>Zu Beginn implementierten wir die grundsätzlichen Funktionen, wie das Auslesen der Messdaten und das Speichern der Daten auf einer MicroSD-Karte, aber auch, dass gleichzeitig die Messzeiten hinzugefügt wurden Dies gestaltete sich relativ einfach, da die Hersteller der verschiedenen Teilsensoren eigene Bibliotheken und Guides bereitstellten, um die Programmierung zu erleichtern, sodass wir nur Funktionen abrufen mussten, die die Messwerte der Sensoren angaben, und diese mussten wir dann zusammen mit der Zeit in eine              Datei (.CSV). Dieser Zyklus wiederholte sich immer zu einer bestimmten Zeit, dem Messintervall, denn eigentlich gibt der Sensor andauernd neue Werte an, aber diese werden nur zu bestimmten Zeiten gespeichert. Die Zeilen unseres Codes wuchsen rasant, bald schon stiessen wir auf eine der grossen Schwächen der Arduino IDE, denn die Übersichtlichkeit von längeren Abschnitten an Code war äusserst gering, weshalb wir uns entschieden den Code fortan nicht mehr in der Arduino IDE, sondern in Visual Studio Code, eine andere IDE, die von Microsoft entwickelt wurde, aber Open Source ist, den Code zu schreiben. Nachdem diese Hürde aus dem Weg geschafft war, konnten wir uns der weiteren Programmierung widmen. Zuerst entwickelten wir die Steuerung des Gerätes, dieses sollte einerseits analog, aber auch digital kontrollierbar sein. Die analoge Steuerung gewährleisteten wir über einen Drehknopf, ein Drehknopf verfügt über zwei Steuerungsmöglichkeiten, wie man aus dem Namen bereits schliessen kann, nämlich das Drehen und das Drücken des Knopfes. Mithilfe des Drehens sollte das wechseln des Menüs/der Auswahlmöglichkeiten kontrolliert werden, das Drücken sollte den ausgewählten Reiter öffnen, resp. aktivieren/deaktivieren. Die Programmierung fiel uns leicht, man musste nur jeder Bewegung des Drehknopfes die entsprechende Aktion anfügen, einzig die Erhaltung der vorgenommenen Einstellungen über mehrere Sessionen, konnten wir nicht programmieren, was aber auch kein grosses Problem darstellte, denn die Einstellungsmöglichkeiten umfassten nur sehr wenig, man kann das RGB-Licht des Displays, den Messungsintervall und die Bluetoothfunktion.</p>

                                <p>Die digitale Steuerung planten wir über eine Applikation namens «Bluefruit», die der Hersteller unseres Microcontrollers, Adafruit, bereitstellte. Diese Applikation, kann sich über Bluetooth mit verschiedensten Geräten, die dieser Verbindung fähig sind, verbinden. «Bluefruit» ermöglicht es nicht nur über die Bluetoothverbindung, nicht nur über UART  (siehe Infokasten Verbindungen zu kommunizieren, sondern es ist auch möglich andere Informationen, wie den Akkustand, und in unserem Fall, auch direkt die Daten graphisch über einen Plotter zu betrachten. Aber um die Verbindung mit dem Gerät über die App mussten wir unseren Code erweitern um die Kommunikation zu ermöglichen. Das war nicht schwer, denn mit einem Handbuch von Adafruit wurde auch ein Code überliefert, den wir dann selbst in unser Programm einfügten.</p>

                                <p>Zuletzt wollten wir noch die Möglichkeit haben, die Daten auf andere Geräte übertragen zu können, denn in der Rohform konnten keine Daten übertragen werden, da das Gerät nicht als Speichermedium erkannt wurde, und man daher auch keinen Zugriff auf die Dateien hatte. Gleichzeitig wollten wir aber auch nicht, dass man aus Versehen den Code auf dem Microcontroller löscht, daher sollte es nur möglich sein auf die Daten, der MicroSD-Karte Zugriff zu haben. Hierzu mussten wir mit dem Messgerät ein USB-Speichermedium emulieren, das aber nur die Dateien auf der MicroSD-Karte ausgab. Diese Programmierung stellte sich schwerer dar als sie zuerst schien, sie war viel komplizierter, als es die Fassade wirken liess. Glücklicherweise fanden wir aber wieder ein Handbuch, das den grundsätzlichen Code lieferte, den wir dann mit einigen Anpassungen an unser Programm anhängten.</p>
                            </div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                    </section>
                    <!-- end section -->

                    <section id="line3" class="section">

                        <div class="row">
                            <div class="col-md-12 left-align">
                                <h2 class="dark-text">Sensoren<hr></h2>
                            </div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                        <div class="row">
                            <div class="col-md-12">
                                <p></p>
                            </div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                    </section>
                    <!-- end section -->

                    <section id="line4" class="section">

                        <div class="row">
                            <div class="col-md-12 left-align">
                                <h2 class="dark-text">Messung<hr></h2>
                            </div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                        <div class="row">
                            <div class="col-md-12">
                                <p>Nachdem wir das Gerät und alle unterstützenden Mittel fertiggestellt hatten, kamen wir zum zweiten Hauptteil unseres Projekts, dem Erfassen der Daten und der Aufbereitung ebengenannter. Aber bevor die Datenerfassung beginnen konnte, musste der Sensor noch kalibriert werden, denn sonst wären die Daten sehr ungenau, man könnte das Gerät direkt in Aarau kalibrieren, aber dort verfügten wir nicht über genaue CO2 Messwerte, einzig verfügten wir über CO2 Werte einer Messstation der Universität Bern auf dem Jungfraujoch. Daher mussten wir uns an eine Lage begeben, die einigermassen abgeschieden war, sodass der CO2 Wert sich möglichst dem Wert auf dem Jungfraujoch annähern kann, als diese Lage wählten wir den Hombergegg auf 778 m.ü.M. Dort kalibrierten wir ihn auf die Messwerte des Jungfraujochs.</p>

                                <p>Die Datenerfassung war eigentlich trivial, einzig die Stromversorgung und die Platzierung des Gerätes erforderte einiges an Geschick. Die Stromversorgung wird bei unserem Gerät, wie vielleicht schon ersichtlich wurde, nicht über einen internen Akku gewährleistet, sondern über einen USB-C Anschluss, der an eine Energiequelle angeschlossen wird. Als Energiequelle nutzten wir entweder Powerbanks oder wir schlossen das Gerät über einen Adapter direkt an den heimischen Stromanschluss an. Powerbanks kamen zum Einsatz, wenn wir an schwer erreichbaren oder abgelegenen Orten massen, sonst nutzten wir den Strom aus der Steckdose. Die Platzierung erforderte insofern Geschick, weil das Gerät nicht an einer exponierten Stelle stehen sollte, da dadurch Wind, der die Messergebnisse verfälscht, durch das Gerät fegen kann. Man muss das Gerät an eine möglichst Windgeschützte Position stellen, aber gleichzeitig sollte die Luftzufuhr noch immer ausreichend sein.</p>

                                <p>Nach dem Abschluss der Positionierung und der Stromversorgung, steht der Datenerfassung nichts im Wege, man muss nur noch den Vorgang über eine der vielen Kommunikationsmöglichkeiten starten. Während dem Erfassen der Daten, benötigt das Gerät keinerlei Aufmerksamkeit, sodass man auch über einen längeren Zeitraum, wir massen teilweise drei Tage am Stück, messen kann.</p>
                            </div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                    </section>
                    <!-- end section -->

                    <section id="line5" class="section">

                        <div class="row">
                            <div class="col-md-12 left-align">
                                <h2 class="dark-text">Auswertung der Daten<hr></h2>
                            </div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                        <div class="row">
                            <div class="col-md-12">
                                <p>Auf die Datenerfassung folgt die Datenaufbereitung. Unsere Daten werden als .CSV-Dateien aufgezeichnet. Eine CSV-Datei, ist eigentlich eine normale Textdatei, die aber ein ganz bestimmtes Format aufweist. CSV-Dateien sind für die Datenaufzeichnung optimiert, CSV-Dateien werden als Textdatei aufgezeichnet mit einem speziellen Layout, Datensätze (die Werte der Sensoren zu einer bestimmten Zeit) werden durch einen Zeilenumbruch getrennt, und die Datenfelder (die Werte der einzelnen Sensoren) werden durch ein Sonderzeichen, meist ein Komma, abgetrennt.</p>

                                <p>Die erfassten CSV-Dateien exportierten wir in Excel und wandelten sie in eine Excel-Datei um, dieser Vorgang geschah automatisch. Nach der Umwandlung, wodurch die Daten erst wirklich nutzbar wurden, sortierten wir die Daten in Excel und erstellten Diagramme für die Werte des CO2-Sensors, der Luftfeuchtigkeit, der Temperatur und die verschiedenen Arten der erfassten Feinstaubwerte. Um die Visualität der Graphiken zu verbessern, erstellten wir die Graphiken nicht mit den Rohdaten, sondern rechneten zuerst noch die Mediane von gewissen Zeiten aus. Die Feinstaubgraphiken verbesserten wir des Weiteren noch manuell, da diese Werte sehr klein waren und wir nur einen Trend erkennen wollten, der mit den einfachen Medianen nicht sichtbar wäre. Die gesamten Änderungen übernahmen wir in eine Excel Datei, die als «Template» dienen sollte, wenn man dann einen bestimmten Datensatz betrachten will, kann man in Excel die entsprechende Datei als Datenquelle einfügen, und diese anschliessend betrachten.</p>

                                <p>Im Zuge unserer Betrachtungen, stellten wir fest, dass ein augenblicklicher Überblick über die aktuelle Messung fehlte, auch war die immerwährende langwierige Prozedur, um die Daten auswerten zu können, äusserst nervenaufreibend. Daher beschlossen wir die Datenbetrachtung fortan nicht mehr über Excel durchzuführen, sondern über ein eigenes Werkzeug, das über das Internet abrufbar ist. Dadurch ist es Möglich die Messwerte einer aktuellen Messung aus der Ferne betrachten zu können, solange das Messgerät mit dem Internet verbunden ist. Neben dem Betrachten der Livedaten soll das Werkzeug es auch ermöglichen die Daten vergangener Messungen zu betrachten, und diese auch zu exportieren. Wir strukturierten unser Werkzeug in zwei Webseiten auf, eine soll als Datenbank fungieren, und die andere ist die Webseite, auf die der Endbenutzer zugreift, um die Daten zu betrachten. Das Herzstück dieses Systems ist eine API (Application Programming Interface), eine API ist eine Schnittstelle, die bestimmt, wie verschiedene Systeme aus Abfragenden (Clients) und den Antwortenden (Server) kommunizieren können, . In unserem Fall regelt die API die Abfragen der Webseite (Client) an die Datenbank (Server), denn auf der Webseite sind alle gesammelten Daten abgespeichert. Wenn man die Daten einer bestimmten Messung, sehen will, kann man auf einen Button «Load Files» klicken, die Webseite sendet eine Abfrage nach den vorhandenen Dateien über ein HTTP-Protokoll, und erhält eine Antwort, anschliessend werden die vorhandenen Dateien mit Datum und Zeitspanne angezeigt. Wählt man eine Datei an, wird wieder eine Abfrage an den Server nach den Daten gesendet, dieser liefert die Daten an die Webseite, in welcher die Daten aufgeschlüsselt und über eine JavaScript-API, in die graphischen Darstellungen umgewandelt werden. Diese API ermöglicht auch das Exportieren der Daten als Diagramme in Form von .jpeg oder .png Dateien. Neben dem JavaScript mussten wir auch ein HTML-Dokument und ein CSS-Stylesheet für unsere Webseite entwerfen. Die Datenbank, die auf Python basiert, hosteten wir über einen Dienst namens «Pythonanywhere», der es möglich macht Pythonanwendungen auf eigenen Webseiten auszuführen, und die eigentliche Webseite hosteten wir über den Dienstleister GitHub, dieser ermöglicht eine freie Gestaltung und auch verfügten wir über eine professionelle Lizenz, da GitHub ein Programm für Studierende anbietet, das ihnen ermöglicht eine kostenfreie professionelle Lizenz, und viele andere Vorteile auch bei anderen Anbietern bietet.</p>
                            </div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                    </section>
                    <!-- end section -->

                    <section id="line6" class="section">

                        <div class="row">
                            <div class="col-md-12 left-align">
                                <h2 class="dark-text">Funktion einer Website<hr></h2>
                            </div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                        <div class="row">
                            <div class="col-md-12">
                                <p></p>
                            </div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                    </section>
                    <!-- end section -->

                    <section id="line7" class="section">

                        <div class="row">
                            <div class="col-md-12 left-align">
                                <h2 class="dark-text">Datenanalyse<hr></h2>
                            </div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                        <div class="row">
                            <div class="col-md-12">
                                <p></p>
                            </div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                    </section>
                    <!-- end section -->

                    <section id="line8" class="section">

                        <div class="row">
                            <div class="col-md-12 left-align">
                                <h2 class="dark-text">Schlusswort<hr></h2>
                            </div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                        <div class="row">
                            <div class="col-md-12">
                                <p></p>
                            </div>
                            <!-- end col -->
                        </div>
                        <!-- end row -->

                    </section>
                    <!-- end section -->

                </div>
                <!-- // end .col -->

            </div>
            <!-- // end .row -->

        </div>
        <!-- // end container -->

    </div>
    <!-- end wrapper -->

    <script src="js/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/retina.js"></script>
    <script src="js/jquery.fitvids.js"></script>
    <script src="js/wow.js"></script>
    <script src="js/jquery.prettyPhoto.js"></script>

    <!-- CUSTOM PLUGINS -->
    <script src="js/custom.js"></script>
    <script src="js/main.js"></script>

    <script src="js/syntax-highlighter/scripts/shCore.js"></script>
    <script src="js/syntax-highlighter/scripts/shBrushXml.js"></script>
    <script src="js/syntax-highlighter/scripts/shBrushCss.js"></script>
    <script src="js/syntax-highlighter/scripts/shBrushJScript.js"></script>

</body>

</html>
